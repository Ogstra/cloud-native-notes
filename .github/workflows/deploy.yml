name: Deploy Application

on:
  push:
    branches:
      - main
    paths:
      - "app/**"
      - ".github/workflows/deploy.yml"
  workflow_dispatch:

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: true

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY_BACKEND: dev-backend
  ECR_REPOSITORY_FRONTEND: dev-frontend
  ECS_SERVICE: dev-service
  ECS_SERVICE_FRONTEND: dev-frontend-service
  ECS_CLUSTER: dev-cluster
  ECS_MIGRATION_TASK_FAMILY: dev-migration
  LOG_GROUP_BACKEND: /ecs/dev-app
  LOG_GROUP_FRONTEND: /ecs/dev-frontend

jobs:
  deploy:
    name: Deploy
    runs-on: ubuntu-latest
    environment:
      name: production
      url: ${{ vars.APP_URL }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          role-session-name: github-actions-deploy
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and Push Images
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          set -euo pipefail
          MIGRATION_TAG="${IMAGE_TAG}-migration"

          docker build -f app/backend/Dockerfile -t $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:$IMAGE_TAG .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:$IMAGE_TAG
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:latest

          docker build --target builder -f app/backend/Dockerfile -t $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:$MIGRATION_TAG .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:$MIGRATION_TAG
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:$MIGRATION_TAG $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:migration
          docker push $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:migration

          docker build -f app/frontend/Dockerfile -t $ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:$IMAGE_TAG ./app/frontend
          docker push $ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:$IMAGE_TAG
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:latest

          echo "backend_image=$ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "frontend_image=$ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "migration_image=$ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:$MIGRATION_TAG" >> $GITHUB_OUTPUT

      - name: Register Task Definitions
        id: taskdefs
        env:
          BACKEND_IMAGE: ${{ steps.build-image.outputs.backend_image }}
          FRONTEND_IMAGE: ${{ steps.build-image.outputs.frontend_image }}
          MIGRATION_IMAGE: ${{ steps.build-image.outputs.migration_image }}
        run: |
          set -euo pipefail

          BACKEND_SERVICE_TD=$(aws ecs describe-services \
            --cluster $ECS_CLUSTER \
            --services $ECS_SERVICE \
            --query "services[0].taskDefinition" \
            --output text)

          FRONTEND_SERVICE_TD=$(aws ecs describe-services \
            --cluster $ECS_CLUSTER \
            --services $ECS_SERVICE_FRONTEND \
            --query "services[0].taskDefinition" \
            --output text)

          MIGRATION_TD=$(aws ecs describe-task-definition \
            --task-definition $ECS_MIGRATION_TASK_FAMILY \
            --query "taskDefinition.taskDefinitionArn" \
            --output text)

          NETWORK_JSON=$(aws ecs describe-services \
            --cluster $ECS_CLUSTER \
            --services $ECS_SERVICE \
            --query "services[0].networkConfiguration.awsvpcConfiguration" \
            --output json)

          SUBNETS=$(echo "$NETWORK_JSON" | jq -r '.subnets | join(",")')
          SECURITY_GROUPS=$(echo "$NETWORK_JSON" | jq -r '.securityGroups | join(",")')
          ASSIGN_PUBLIC_IP=$(echo "$NETWORK_JSON" | jq -r '.assignPublicIp')

          aws ecs describe-task-definition --task-definition "$BACKEND_SERVICE_TD" --query "taskDefinition" --output json > backend-td.json
          HAS_DATABASE_URL=$(jq -r '[.containerDefinitions[] | select(.name == "backend") | (.secrets // [])[] | select(.name == "DATABASE_URL")] | length' backend-td.json)
          HAS_JWT_SECRET=$(jq -r '[.containerDefinitions[] | select(.name == "backend") | (.secrets // [])[] | select(.name == "JWT_SECRET")] | length' backend-td.json)
          HAS_PORT=$(jq -r '[.containerDefinitions[] | select(.name == "backend") | (.environment // [])[] | select(.name == "PORT")] | length' backend-td.json)

          if [ "$HAS_DATABASE_URL" = "0" ]; then
            echo "Backend task definition is missing DATABASE_URL secret. Run Terraform apply first."
            exit 1
          fi
          if [ "$HAS_JWT_SECRET" = "0" ]; then
            echo "Backend task definition is missing JWT_SECRET secret. Run Terraform apply first."
            exit 1
          fi
          if [ "$HAS_PORT" = "0" ]; then
            echo "Backend task definition is missing PORT environment variable. Run Terraform apply first."
            exit 1
          fi
          jq --arg IMAGE "$BACKEND_IMAGE" '
            .containerDefinitions |= map(if .name == "backend" then .image = $IMAGE else . end)
            | del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)
          ' backend-td.json > backend-td-rendered.json
          NEW_BACKEND_TD=$(aws ecs register-task-definition --cli-input-json file://backend-td-rendered.json --query "taskDefinition.taskDefinitionArn" --output text)

          aws ecs describe-task-definition --task-definition "$FRONTEND_SERVICE_TD" --query "taskDefinition" --output json > frontend-td.json
          jq --arg IMAGE "$FRONTEND_IMAGE" '
            .containerDefinitions |= map(if .name == "frontend" then .image = $IMAGE else . end)
            | del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)
          ' frontend-td.json > frontend-td-rendered.json
          NEW_FRONTEND_TD=$(aws ecs register-task-definition --cli-input-json file://frontend-td-rendered.json --query "taskDefinition.taskDefinitionArn" --output text)

          aws ecs describe-task-definition --task-definition "$MIGRATION_TD" --query "taskDefinition" --output json > migration-td.json
          jq --arg IMAGE "$MIGRATION_IMAGE" '
            .containerDefinitions |= map(if .name == "migration" then .image = $IMAGE else . end)
            | del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)
          ' migration-td.json > migration-td-rendered.json
          NEW_MIGRATION_TD=$(aws ecs register-task-definition --cli-input-json file://migration-td-rendered.json --query "taskDefinition.taskDefinitionArn" --output text)

          echo "backend_td=$NEW_BACKEND_TD" >> $GITHUB_OUTPUT
          echo "frontend_td=$NEW_FRONTEND_TD" >> $GITHUB_OUTPUT
          echo "migration_td=$NEW_MIGRATION_TD" >> $GITHUB_OUTPUT
          echo "subnets=$SUBNETS" >> $GITHUB_OUTPUT
          echo "security_groups=$SECURITY_GROUPS" >> $GITHUB_OUTPUT
          echo "assign_public_ip=$ASSIGN_PUBLIC_IP" >> $GITHUB_OUTPUT

      - name: Run Migration Task And Wait
        run: |
          set -euo pipefail

          OVERRIDES=$(jq -nc '{
            containerOverrides: [
              {
                name: "migration",
                command: ["sh", "-c", "sh ./scripts/migrate-safe.sh"]
              }
            ]
          }')

          TASK_ARN=$(aws ecs run-task \
            --cluster $ECS_CLUSTER \
            --task-definition "${{ steps.taskdefs.outputs.migration_td }}" \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[${{ steps.taskdefs.outputs.subnets }}],securityGroups=[${{ steps.taskdefs.outputs.security_groups }}],assignPublicIp=${{ steps.taskdefs.outputs.assign_public_ip }}}" \
            --overrides "$OVERRIDES" \
            --query 'tasks[0].taskArn' \
            --output text)

          if [ -z "$TASK_ARN" ] || [ "$TASK_ARN" = "None" ]; then
            echo "Migration task failed to start"
            exit 1
          fi

          aws ecs wait tasks-stopped --cluster $ECS_CLUSTER --tasks "$TASK_ARN"

          EXIT_CODE=$(aws ecs describe-tasks \
            --cluster $ECS_CLUSTER \
            --tasks "$TASK_ARN" \
            --query "tasks[0].containers[?name=='migration'] | [0].exitCode" \
            --output text)

          if [ "$EXIT_CODE" != "0" ]; then
            echo "Migration failed with exit code: $EXIT_CODE"
            aws logs tail /ecs/dev-migration --since 15m || true
            exit 1
          fi

      - name: Update Services And Wait
        run: |
          set -euo pipefail

          aws ecs update-service --cluster $ECS_CLUSTER --service $ECS_SERVICE --task-definition "${{ steps.taskdefs.outputs.backend_td }}" --force-new-deployment
          aws ecs update-service --cluster $ECS_CLUSTER --service $ECS_SERVICE_FRONTEND --task-definition "${{ steps.taskdefs.outputs.frontend_td }}" --force-new-deployment

          wait_for_service() {
            local service="$1"
            local timeout_seconds=1800
            local interval=15
            local elapsed=0

            echo "Waiting for ECS service to stabilize: $service"

            while [ "$elapsed" -lt "$timeout_seconds" ]; do
              SERVICE_JSON=$(aws ecs describe-services --cluster "$ECS_CLUSTER" --services "$service")

              DESIRED=$(echo "$SERVICE_JSON" | jq -r '.services[0].desiredCount')
              RUNNING=$(echo "$SERVICE_JSON" | jq -r '.services[0].runningCount')
              PENDING=$(echo "$SERVICE_JSON" | jq -r '.services[0].pendingCount')
              PRIMARY_ROLLOUT=$(echo "$SERVICE_JSON" | jq -r '.services[0].deployments[] | select(.status=="PRIMARY") | .rolloutState')
              IN_PROGRESS_DEPLOYS=$(echo "$SERVICE_JSON" | jq -r '[.services[0].deployments[] | select(.rolloutState != "COMPLETED")] | length')

              echo "[$service] desired=$DESIRED running=$RUNNING pending=$PENDING rollout=$PRIMARY_ROLLOUT in_progress_deployments=$IN_PROGRESS_DEPLOYS"

              if [ "$PRIMARY_ROLLOUT" = "FAILED" ]; then
                echo "Primary deployment failed for service: $service"
                return 1
              fi

              if [ "$RUNNING" = "$DESIRED" ] && [ "$PENDING" = "0" ] && [ "$PRIMARY_ROLLOUT" = "COMPLETED" ]; then
                echo "Service stabilized: $service"
                return 0
              fi

              sleep "$interval"
              elapsed=$((elapsed + interval))
            done

            echo "Timeout while waiting for service stabilization: $service"
            return 1
          }

          print_service_diagnostics() {
            local service="$1"
            echo ""
            echo "===== Diagnostics for $service ====="
            aws ecs describe-services \
              --cluster "$ECS_CLUSTER" \
              --services "$service" \
              --query "services[0].events[0:10].[createdAt,message]" \
              --output table || true

            STOPPED_TASKS=$(aws ecs list-tasks \
              --cluster "$ECS_CLUSTER" \
              --service-name "$service" \
              --desired-status STOPPED \
              --max-items 5 \
              --query "taskArns" \
              --output text || true)

            if [ -n "${STOPPED_TASKS:-}" ] && [ "$STOPPED_TASKS" != "None" ]; then
              aws ecs describe-tasks \
                --cluster "$ECS_CLUSTER" \
                --tasks $STOPPED_TASKS \
                --query "tasks[].{taskArn:taskArn,lastStatus:lastStatus,stoppedReason:stoppedReason,containers:containers[].{name:name,reason:reason,exitCode:exitCode}}" \
                --output json || true
            else
              echo "No recently stopped tasks found for $service"
            fi
          }

          set +e
          wait_for_service "$ECS_SERVICE"
          BACKEND_WAIT_EXIT=$?
          wait_for_service "$ECS_SERVICE_FRONTEND"
          FRONTEND_WAIT_EXIT=$?
          set -e

          if [ "$BACKEND_WAIT_EXIT" -ne 0 ] || [ "$FRONTEND_WAIT_EXIT" -ne 0 ]; then
            print_service_diagnostics "$ECS_SERVICE"
            print_service_diagnostics "$ECS_SERVICE_FRONTEND"

            echo ""
            echo "===== Backend logs (last 15m) ====="
            aws logs tail "$LOG_GROUP_BACKEND" --since 15m || true

            echo ""
            echo "===== Frontend logs (last 15m) ====="
            aws logs tail "$LOG_GROUP_FRONTEND" --since 15m || true

            exit 1
          fi
